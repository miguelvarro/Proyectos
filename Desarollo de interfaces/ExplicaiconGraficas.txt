Este proyecto es un Server Monitor + Informe con gráficas hecho con dos piezas:

Un script Python (server_monitor.py) que recoge métricas del sistema y las va guardando en CSV dentro de monitor_data/.

Un único PHP (monitor.php) que actúa a la vez como API JSON protegida y como dashboard/informe web con gráficas SVG (sin librerías externas).

Qué hace el proyecto (funcionalidad base)
1) Recolección de datos (Python)

El script usa psutil para capturar:

CPU: porcentaje de uso.

RAM: porcentaje y total.

Disco (uso): porcentaje, total y libre.

Disk I/O: lecturas/escrituras (bytes, operaciones, tiempos) por disco.

Bandwidth: bytes enviados/recibidos por interfaz de red.

Processes: snapshot de procesos (por ejemplo nombre y memoria en MB).

Request rate Apache: calcula peticiones/minuto leyendo el access.log de XAMPP/Apache.

Todo eso se vuelca a CSV (uno por métrica; en bandwidth y disk I/O se generan varios CSV según interfaz/disco).

2) Visualización (PHP Dashboard)

Si abres monitor.php sin parámetros, se muestra una interfaz tipo panel:

Tarjetas con gráficas line, bar y pie en SVG.

Estética “naranja/negro”.

Leyendas opcionales por tarjeta.

Tooltips al pasar el ratón por puntos/barras/porciones.

3) API JSON (PHP Endpoints)

Si llamas a:

monitor.php?endpoint=cpu (o ram, disk_usage, disk_io, bandwidth, processes, apache_request_rate)

Devuelve los datos en JSON, protegido con Basic Auth.

Además soporta parámetros opcionales:

iface=... para bandwidth (elige interfaz)

disk=... para disk_io (elige disco)

Lo añadido (mejoras “de informe”)
A) Informe con rango temporal (15m / 1h / 24h)

Se añadió un selector de rango que traduce a:

from=YYYY-mm-dd HH:ii:ss

to=YYYY-mm-dd HH:ii:ss

El endpoint filtra filas del CSV por fecha cuando la métrica tiene date.
Para métricas “snapshot” como processes, se ajustó para que no se quede vacío aunque no haya date.

B) Auto-refresh (modo “tiempo real”)

El dashboard puede refrescar automáticamente cada X segundos (2s/5s/10s).

Se añadió “cache busting” en el fetch() (_ts=Date.now() y no-store) para que el navegador no devuelva respuestas cacheadas y evitar el efecto de “sale en blanco hasta refrescar”.

C) KPI y alertas visuales

Cada tarjeta muestra KPIs calculados:

last / avg / max en el rango visible.

Y alertas:

CPU alta o RAM alta → borde rojo + animación suave.

Request rate alto → etiqueta “ALTA CARGA”.

D) Endpoints configurables desde UI

Se añadió en la barra superior:

Selector de Interface (bandwidth) detectando CSV disponibles.

Selector de Disk (disk_io) detectando CSV disponibles.

Esto hace que la misma página sirva para cualquier PC/interfaz/disco sin tocar código.

E) Exportación tipo informe

Botón “Exportar (imprimir)”:

Genera una vista imprimible (CSS print) para guardar como PDF desde el navegador.

Ajuste clave para BANDWIDTH (para que siempre se vea)

El gráfico de bandwidth se calculó como:

Delta (KB por muestra) usando cambios entre filas (recv+sent).

Pero si no hay tráfico, los deltas son 0 y el gráfico queda plano.
Se añadió un fallback automático:

Si todos los deltas son 0, se muestra acumulado en MB para que siempre haya barras visibles.