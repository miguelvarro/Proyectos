Descripción del proyecto

El proyecto implementa un sistema cliente–servidor orientado a cómputo multinúcleo que permite lanzar tareas pesadas desde una interfaz web y recibir el resultado en tiempo real. La aplicación se centra en dos tipos de trabajos:

Renderizado CPU con Path Tracing: genera una imagen a partir de una escena (esferas + plano) mediante trazado de rayos con muestreo Monte Carlo.

Empaquetado ZIP de resultados: genera un ZIP con los renders generados.

La comunicación entre el navegador y el backend se hace por WebSockets para tener un canal persistente donde enviar:

petición de trabajo (render, zip_outputs)

progreso de ejecución

resultado final (archivo en base64)

Además, se usa paralelismo real en el servidor: el render se divide por filas y se computa en paralelo usando varios procesos (aprovechando múltiples núcleos). En el lado del cliente se usa un Web Worker para mantener la interfaz fluida al procesar/mostrar logs y eventos sin bloquear el hilo principal del navegador.

Qué hace cada parte (visión de arquitectura)
Frontend (navegador)

Conecta a ws://127.0.0.1:8765

Envía acciones en JSON:

{"action":"render", "scene": {...}}

{"action":"zip_outputs"}

Recibe mensajes:

hello: confirmación del servidor

job: estado del job (queued/running/done/error)

progress: porcentaje y mensaje

result: archivo final en base64 + nombre

El frontend crea un enlace de descarga automático con un Blob cuando recibe el result.

Backend (servidor Python)

Mantiene un servidor WebSocket que escucha conexiones

Enruta mensajes por action

Crea un job con id y estado

Ejecuta la tarea pesada fuera del event loop (para no bloquear) y va notificando progreso

Devuelve el resultado final

Explicación del código (por módulos)
backend/server.py

Es el núcleo de la aplicación.

Servidor WebSocket: acepta conexiones y maneja mensajes JSON.

Router de acciones: según action llama a handle_render o handle_zip.

Gestión de jobs: crea un job_id, actualiza estados y manda al cliente:

queued → running → done/error

Ejecución sin bloquear: usa asyncio.to_thread(...) para ejecutar funciones pesadas en un hilo sin congelar el servidor.

Progreso thread-safe: se captura el event loop principal y se usa asyncio.run_coroutine_threadsafe(...) para enviar mensajes WS desde el hilo del trabajo sin romper asyncio.

backend/jobs/job_manager.py

Gestiona el “modelo” de trabajo:

Job con job_id, kind, status, meta, error.

JobManager para crear jobs y cambiar estado.

backend/engines/pathtracer/tracer.py

Implementa el Path Tracer:

Vector math mínima (suma, resta, dot, normalización).

Intersecciones:

esfera (ecuación cuadrática)

plano (suelo)

ray_color: rebotes difusos (Lambert) con profundidad limitada.

Fondo degradado (sky).

Salida a PPM P6 (fácil y robusto).

Paralelismo multinúcleo:

La imagen se divide por filas (_render_row(y, ...))

Se lanza ProcessPoolExecutor con os.cpu_count() procesos

Se recogen filas con as_completed

Se notifica progreso cada cierto número de filas

Resultado: render_...ppm se guarda en backend/output/renders y se devuelve también como bytes para enviarlo al navegador.

backend/engines/zip_multicore/zipper.py

Implementa el empaquetado de outputs:

Recorre backend/output/renders

Pipeline multinúcleo:

lectura de archivos + cálculo CRC en paralelo con ProcessPoolExecutor

Construcción del contenedor ZIP (modo STORE para simplicidad/robustez)

Guarda outputs.zip en backend/output/zips

Devuelve bytes para descarga directa

frontend/js/ws_client.js

Cliente WebSocket encapsulado:

connect() abre conexión y gestiona eventos

send(obj) envía JSON

frontend/js/app.js

Control de UI:

Botones conectar/render/zip

Construye una escena por defecto y la manda al servidor

Maneja mensajes (progress, result) y crea descargas

Envía logs al worker para formateo

frontend/js/workers/ui_worker.js

Worker dedicado a:

Procesar/formatear logs sin bloquear el hilo principal

Devuelve texto ya formateado para pintar en el <pre>

Funcionalidades añadidas durante el desarrollo (lo “nuevo” que se incorporó)

Integración completa WebSocket cliente-servidor con protocolo JSON (acciones, progreso y resultados).

Sistema de jobs con estados claros (queued/running/done/error) y job_id para trazabilidad.

Render Path Tracer en backend con:

escena base

muestreo por pixel

rebotes difusos

salida en PPM binario

Paralelización multinúcleo real en el render usando procesos (división por filas).

Compresor ZIP de outputs con pipeline paralelo (lectura + CRC en procesos).

Descarga directa en el navegador de archivos generados (render y zip) usando base64 + Blob.

Web Worker en frontend para que el log y el tratamiento de mensajes no congele la interfaz.

Corrección de concurrencia con asyncio: envío de progreso desde hilos al loop principal de forma segura (la causa del error de “no current event loop”).